2:32:04
will perhaps be quite the eye opener as to what you can really do now that you have classes at your disposal.
2:32:10
And this, too, surprise, has been a feature you and I have been taking for granted for weeks now.
2:32:15
This has just worked, but it's been implemented in a way that you can now leverage yourself. It turns out that Python, and some other languages, too,
2:32:23
support this notion of operator overloading, whereby you can take very common symbols, like plus or minus or other such syntax
2:32:32
on the keyboard, and you can implement your own interpretation thereof.
2:32:37
Plus does not have to equal addition. And minus does not have to equal subtraction.
2:32:43
And in fact, you and I have already seen another context in which plus means something else.
2:32:48
Plus has not always, in Python, meant addition, per se. What else has Python used plus for?
2:32:56
AUDIENCE: Concatenation? DAVID J. MALAN: For concatenation. For joining two strings, for adding to a list can you use plus as well.
2:33:02
So plus has actually been, funny enough, overloaded by the authors of Python for us.
2:33:08
And so we can use the same symbol in much the same way as addition but with different data types to solve slightly different problems.
2:33:15
Well, let me propose that we go back over to VS Code here, and let me go ahead and create a new final file called vault.py.
2:33:22
So code of vault.py. And let me propose that we implement the idea of a vault
2:33:27
at Gringotts, keeping on theme, wherein there's a bank in the world of Harry Potter. And within this bank, families and individuals
2:33:35
have vaults containing all sorts of money in the wizarding world. And the type of money that exists in the world of Harry Potter
2:33:41
are coins called galleons and sickles and Knuts, and those are in descending order of value.
2:33:47
And so inside of a vault might be a whole bunch of coins-- gold, silver, and bronze, essentially, each in those denominations,
2:33:53
tucked away. So how can I go about implementing, first of all, the idea of a vault
2:33:58
so that I can store, for instance, for Harry Potter, how much coinage is in his family's vault, or for Ron Weasley the same?
2:34:05
Well, let me go ahead and vault.py and first create a class called Vault, essentially meant to represent a bank vault.
2:34:12
Perfect, another real world, or fantasy world, entity that I want to represent with code.
2:34:17
I could use a tuple or a list or a dictionary. But again, I'm going to get a lot more functionality with classes,
2:34:23
and we'll see one final flourish with operators. Inside of this vault class, let's go ahead and do this.
2:34:28
Let me define my init method, taking its first argument of self. And let me define three arguments to this.
2:34:35
When you create a vault, in my code here, I want to be able to initialize it with some number of galleons, some number
2:34:41
of sickles and, some number of Knuts. I want the user, the programmer, to be able to pass in one or more
2:34:46
of those values ideally. But they can be optional, so I'll give them defaults. So let's go ahead and define a parameter called galleons,
2:34:53
whose default value will be 0; sickles, whose default value will also be 0; and knuts, whose default value will be 0 as well.
2:35:00
So the programmer can pass in one or two or three or even none of those, and they'll all have some implied defaults.
2:35:07
How do I want to remember those values that are passed in? Well, let me do this. self.galleons = galleons.
2:35:14
And self.sickles = sickles. And self.knuts = knuts.
2:35:20
And so I could add some error checking, especially if you don't pass in. A number I could turn these into properties to do even more validation.
2:35:27
But let's keep it simple and, as always, focus only on the new ideas. So I'm just going to trust that these values were passed in,
2:35:33
and I'm going to immediately assign them to these instance variables. What, now, do I want to do?
2:35:38
Well, let's come up with a way of printing out what is in someone's vault, ultimately.
2:35:44
But first let's do this. Let's create a vault for the Potters by creating, via assignment, a new vault.
2:35:50
And let's say that the potters have 100 galleons, 50 sickles, and 24 knuts.
2:35:55
And that's in that vault. And let's print out, for instance, potter. All right, let's run this code and see how it works now.
2:36:00
Let me go ahead and run Python of vault.py, Enter. Seems to work.
2:36:06
No syntax errors or anything else. But this is not very enlightening. How do I fix this, thinking back to what we've done before?
2:36:15
AUDIENCE: You have to use the __str. DAVID J. MALAN: Exactly. I need to use one of those special methods that comes with classes
2:36:22
and define for myself how I want a vault to be printed as a string. So let me go ahead and do that.
2:36:27
Let me define the str method taking in self as its sole argument here. And let's just return a very simple string
2:36:34
that just reveals what's in the vault. So I'm going to return a formatted f string,
2:36:39
inside of which is self.galleons and then the word galleon, so I know which those are.
2:36:45
Then let's do self.sickles, and let's output the word, sickles. And then lastly let's output self.knuts, and then knuts here.
2:36:53
So I know, in this string, just how many of each of those coins I have in this particular family's vault. All right, let me go ahead
2:37:01
and run Python of vault.py, changing nothing else except the str method. And now, , we, see indeed that Harry has 100 galleons, 50 sickles, and 25 knuts.
2:37:11
All right, well, let's do one thing more here. Below that, let's go ahead and define a Weasley variable.
2:37:16
And Ron never seemed to have quite as much money in the vault as did Harry. So let's say that the Weasley vault will have 25, 50, and 100.
2:37:24
So I'll just reverse the order of those denominations, rather than Harry's 100, 50, 25. And now let me go ahead and print Weasley like this.
2:37:33
And let's go ahead and clear my terminal window, run Python of vault.py. This time, that str method will be invoked twice, once
2:37:40
for each of those vault objects. And we'll see, indeed, that the first one for Harry has got 100, 50, and 25, respectively, versus Ron's 25, 50,
2:37:48
and 100, respectively. But now let's do something interesting. Suppose that you wanted to combine the contents of two vaults,
2:37:56
be it Harry's and Ron's or any other two people. How would you go about doing this in code?
2:38:02
Well, if I wanted to combine the vaults for someone, I could do this. Well, I could do galleons equals--
2:38:08
let's do potter.galleons + weasley.galleons.
2:38:13
That gives me a variable called galleons that has the sum of Harry and Ron's galleons.
2:38:19
Let's next do sickles = potter.sickles + weasley.sickles.
2:38:25
And then lastly, let's do knuts = potter.knuts + weasley.knuts.
2:38:31
I've got three variables. What can I now do with these values? Well, let's create a third-- a new vault. Total will
2:38:37
be the name of this variable equals a new vault, Capital V, notice. And now, let's pass in those three new variables--
2:38:43
galleons, sickles, and knuts. And that's it, and let's print out this total vault.
2:38:49
So we should now see three vaults-- one for Harry, for Ron, and the combination-- the addition of the two.
2:38:55
Let me go ahead and rerun Python of vault.py, and there we have it. What was 100, 50, 25 and 25, 50, and 100, combined through addition now,
2:39:04
is 125, 100, 125. So pretty straightforward, using techniques from weeks
2:39:10
ago, where we're just declaring a few new variables and doing some addition. But wouldn't it be cool if I could do something like this?
2:39:18
Wouldn't it be cool if I could just somehow, not manually create my own vault and do all of this annoying math up here--
2:39:24
what if I could just do potter + weasley and get rid of all of this logic here?
2:39:30
Wouldn't it be nice if I overload the operator-- we know as plus, just like str does, just
2:39:37
like list does-- to allow me to add two vaults together on the left and the right.
2:39:43
Well, it turns out in Python and through operator overloading, there is a way to do just this.
2:39:50
If you consult the documentation, there's this and so many other special methods that come with classes.
2:39:56
The third one we'll see here is this one here-- __add__.
2:40:03
And you'll see that it very generically is described in the documentation is working for any object, be it a vault or str
2:40:09
or a list or something else. By convention, it's going to take a first argument called self, and then it's going to take some other argument, by convention, called other.
2:40:17
self, in effect, is going to be referring to whatever object is on the left of a plus sign.
2:40:22
other is going to be referring to whatever is on the right-hand side of a plus sign, thereby giving us a way of describing, in code, the operand
2:40:30
on the left and the operand on the right of the operator, plus, in between.
2:40:35
That is to say, if I go back to VS Code here, what I'm trying to do is implement support for this.
2:40:42
Well, let me try, without writing any other code just yet-- Python of vault.py, Enter--
2:40:47
TypeError: unsupported operand type(s) for +: 'Vault' and 'vault.'
2:40:53
That is to say Python, at this moment, does not know what it means to add two vaults together.
2:40:59
You and I might have an instinct. Probably want to combine the galleons and the sickles and the knuts respectively.
2:41:04
Python doesn't know that. It just knows that you have a new class called Vault. But let's teach Python to do this.
2:41:10
Let me clear my terminal window. Let me scroll back up to the class itself, where, at the moment, I only have two special methods-- init and str.
2:41:18
But let's add this third. Let me go into the class here and define __add__ and then specify its first
2:41:26
parameter as self, as before, and then a second parameter for this particular method called, by convention, other.
2:41:32
Now, as always, I could name those parameters anything I want, but I'm going to stick with convention here. And now, inside of this method, am I going
2:41:39
to have to now add together the contents of two vaults? Well, what two vaults? Well, if we scroll down to our goal at hand, the goal, of course,
2:41:46
is to add this vault plus this other vault-- potter plus weasley, respectively. Well, it turns out, in Python, that, when you do overload an operator like
2:41:53
plus, what's going to happen automatically, as soon as Python sees that, is it's going to call that __add__ method,
2:42:01
and it's going to pass into it to arguments-- whatever the operand is on the left-- potter, in this case--
2:42:07
and whatever the operand is on the right-- weasley, in this case. And those values are going to get passed in as self and other, respectively.
2:42:15
What that means is that we can access their contents up here in our implementation of add as follows. Let me go ahead and define a local variable called galleons and set that
2:42:24
equal to, for instance, the sum of self.galleons-- whatever's in Potter's vault in this case,
2:42:30
plus whatever is in Wesley's vault in this case, which would be other.galleons. Let me do the same for sickles.
2:42:36
self.sickles + other.sickles. And let me lastly do that for knuts.
2:42:41
So self.knuts + other.knuts. But at the end of the day, I'm going to need
2:42:47
to return a brand new bigger vault that contains all of those contents together. And if we ultimately want to assign that bigger vault to a variable like total
2:42:56
here, on the left, we'd better return a value from this add method. So I'm going to go ahead and give myself a brand new vault, as by returning
2:43:04
capital Vault, which of course, is going to call my vault function into which I can now pass some of those initialization arguments.
2:43:11
Well, how many galleon, sickles, and knuts do I want this brand new vault to contain? Well, I want it to contain this many galleons this many sickles,
2:43:19
and this many knuts. So ultimately, what we're doing in this implementation of add is adding together those galleons, sickles, and knuts, passing
2:43:27
them to the vault function so that we get a brand new bigger vault, and return that altogether.
2:43:33
So now I've defined this new special method called add that should now just make plus work for two vaults.
2:43:42
Let's see. Let me run down to my terminal window, Python of vault.py and hit Enter. And voila, and now we've implemented an overloaded operator, plus,
2:43:51
to do what you and I as humans would hope would be the case when you add two vaults together. But I've now written the code more specifically
2:43:58
to teach Python what it means concretely to add two vaults together.
2:44:04
And it's with very similar code in effect, underneath the hood, that Python is doing this for two strings,
2:44:09
to concatenate them together, to joining two lists into a new list with list, and so many other classes as well.
2:44:16
Any questions now on operator overloading or this example here.
2:44:22
AUDIENCE: How would you go about creating a function for adding a student and a vault for two separate classes?
2:44:31
Would that be possible? DAVID J. MALAN: Let me see what happens here. I don't know offhand. Let's do this.
2:44:36
Let's create a str and see what happens. If I add Potter plus a str-- str object. Yeah, so it would work.
2:44:42
I'm just figuring this out as I go here, Eric. So just to be clear, what I did was I just changed weasley to str just to see what would
2:44:48
happen when I add a vault plus a str, and it will work, theoretically.
2:44:54
Why? Because so long as the type of value on the left has an add method implemented,
2:45:01
other can be any type that you want. You just have to decide and code what it's
2:45:06
going to mean conceptually to add a vault plus a string, which, in this case, probably doesn't make any sense at all, but it's possible.
2:45:13
It's going to be the operand on the left. And I'm inferring that. I did not know the answer a moment ago. I'm inferring that because what I got was an attribute error here on line 11
2:45:22
because Python did not like this. other.galleons didn't work, but I could make it work by figuring something out.
2:45:29
Really good question. Didn't know that one myself. Other questions on operator overloading?
2:45:35
AUDIENCE: Can you define new operators in Python? DAVID J. MALAN: I don't think so. There is a very long but precise list of operators that you can overload.
2:45:44
I do not believe you can assign arbitrary characters to be operators in Python.
2:45:50
Let me defer to Carter in the chat to-- OK, I'm seeing two of my colleagues are saying, no, not possible. So I'm going to go with my first instinct, no.
2:45:57
Otherwise, that'd be kind of cool. You could make emoji do whatever you want to. How about one final question on operator overloading?
2:46:04
AUDIENCE: Is that the only operation you can do as far as-- can you do a subtraction as well?
2:46:10
DAVID J. MALAN: You can. You can do so many others let me. If, Carter, you don't mind pulling up this URL here--
2:46:16
so this link here-- special method names and today's slides, you'll see a long list of all of the operators that you can overload.
2:46:23
You can do less than, equals than, plus equals, minus equals. Pretty much any symbol you've seen me type on the screen
2:46:29
can be overloaded in the context of classes. So even though, today, we focused entirely
2:46:35
on object-oriented programming, this is a technique that we've been using, really, since the first week of the class because those ints,
2:46:41
those strs, those floats, those lists, those dictionaries, and so much more were already underneath the hood this whole time-- classes
2:46:49
and objects thereof. But you now, as a programmer, have the ability to create your own classes with your own instance or class variables,
2:46:55
with your own instance or class methods, with your own properties, and even with your own custom behavior for operators.
2:47:01
So ultimately, you can absolutely continue using those simple tuples or lists or those dictionaries or other structures
2:47:09
as well. But object-oriented programming, and with it, classes and now these objects is just another tool in your toolkit.
2:47:15
And daresay, as your code gets more sophisticated and your problems get bigger, you'll find that being able to model these real world or even fantasy world entities
2:47:23
with classes and related data and functionality will ultimately just allow you to define code that's not just correct but ever
2:47:30
well-designed as well. This was CS50.