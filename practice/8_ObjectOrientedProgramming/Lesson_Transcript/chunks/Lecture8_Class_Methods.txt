1:47:27
Thus far, I've been deliberate in calling all of our variables instance variables and all of our methods instance
1:47:34
methods. It turns out there's other types of variables and methods out there,
1:47:40
and one of those is called class methods. It turns out that sometimes it's not really necessary or sensible
1:47:48
to associate a function with objects of a class, but rather with the class itself.
1:47:55
An instance, or an object of a class, is a very specific incarnation thereof. Again, on that neighborhood that has a lot of identical looking buildings,
1:48:03
but they're all a little bit different because of different paint and such, sometimes you might have functionality related
1:48:09
to each of those houses that isn't distinct or unique for any of the houses. It's functionality that's going to be exactly the same no
1:48:17
matter the house in question. Same in the world of object-oriented programming. Sometimes you want some functionality, some action
1:48:24
to be associated with the class itself, no matter what the specific object's
1:48:29
own values or instance variables are. And for that, we have a keyword called @classmethod.
1:48:36
This is another decorator-- really, another function-- that you can use to specify that this method is not,
1:48:43
by default, implicitly an instance method that has access to self, the object itself.
1:48:48
This is a class method that's not going to have access to self, but it does know what class it's inside.
1:48:54
So what do I mean by this? Well, let me go back to VS Code here. And let me propose that we create a new file this time implementing
1:49:01
the notion of a-- the sorting hat, from the world of Harry Potter as well, to stay on theme. I'm going to go ahead and run code of hat.py.
1:49:08
And in hat.py, let's implement the notion of the sorting hat. If unfamiliar in the books and in the films
1:49:14
there is literally a pointy hat that, when a student put it's on their head, that sorting hat, so to speak,
1:49:20
decides what house the student is in-- whether it's Gryffindor or something else. So let's implement, in code, this notion of a sorting hat such that,
1:49:29
when we pass to the sorting hat the name of a student, like, quote, unquote, "Harry" this sorting hat, implemented in code,
1:49:36
will tell us what house that student should be in. Well, let's go ahead and do this.
1:49:41
In hat.py, first, let's go ahead and define a class called hat, and then let's get back to implementing it itself.
1:49:49
And I find this to be a helpful technique, not just with teaching but when writing code. I know I want a hat class.
1:49:55
I don't necessarily know what I want it to do yet, so I'm going to create this placeholder, dot, dot, dot, so I'll come back to that.
1:50:01
Let's now try to use this class as though it existed. And from there, I perhaps can realize exactly what
1:50:08
functionality that class needs to have to support my use case. Let me go ahead and create a variable called hat in all lowercase
1:50:14
and instantiate a hat object. So no matter what the hat class ends up looking like,
1:50:21
this is the common syntax for instantiating an object of a certain class. In the past, we saw student, all lowercase,
1:50:28
equals capital Student, open parenthesis, close parentheses, and then eventually, we added in things like name and house.
1:50:35
For now, let's assume that the hat is much simpler than a student, and it only has sorting capabilities.
1:50:41
So I'm not going to even pass any arguments there, too. Let me assume that the sorting hat has one function-- one method inside of it
1:50:50
called, sort. And so if I do hat.sort ("Harry"), let's propose that that prints out what house
1:50:59
that student should be in. So that's it. I'm going to encapsulate-- that is tuck away inside of a hat class--
1:51:06
all of this requisite functionality, and I'm going to print out onto the screen what hat--
1:51:12
what house Harry belongs in. Now I think I need to get into the weeds of actually initializing this class.
1:51:20
Well, let me go ahead and do this. If I don't care to parameterize hat-- I just want to, for instance sort values,
1:51:29
let's go ahead and define this function, sort, first. So let's define sort, as taking a first argument, self,
1:51:35
which is always going to be the case when defining an instance method as before. But the sort method clearly takes one argument from the programmer, me--
1:51:43
namely the student's name. And again, we've seen this dichotomy before. Even though I'm trying to pass in one argument, when I define the method,
1:51:52
it's got to take that many arguments, plus one more-- self which is always going to be automatically passed in by Python
1:51:58
first. What do I want to do? Well, let's go ahead and do something like this.
1:52:06
Print, this name-- how about "is in," "some house."
1:52:12
I'm going to, again, use some placeholder code for myself because I'm not quite sure how to finish implementing this sorting
1:52:18
hat. But I think that's enough to just test where my code is at now. Let me go ahead and run Python of hat.py and hit Enter.
1:52:25
And it looks like, indeed, Harry is in some house. We're not done yet because it's clearly not doing anything interesting,
1:52:31
but it at least is running correctly with no errors. Well, let's go ahead now and decide where--
1:52:40
what house Harry should actually be in by introducing a bit of randomness and choosing a house randomly.
1:52:45
While I can do this in a few ways, Let. Me go ahead and do this. I need to have a list of houses somewhere.
1:52:51
So where can I put that? I could solve this problem in different ways. Let me propose that I do this. Let me define a method called init, as I've done before,
1:52:58
that takes in self, but no other arguments. And whenever the sorting hat is instantiated, let's do this.
1:53:04
Let's create a houses instance variable, plural, that equals this list--
1:53:09
Gryffindor, Hufflepuff, Ravenclaw, Slytherin,
1:53:16
so the exact same list that we've used before, and I'm storing it in an instance variable inside of this class.
1:53:23
I'm not taking any arguments beyond self to init, but I just need this list of values somewhere, for instance.
1:53:30
So what can I do here? Well, let me go ahead and replace some house with the actual house.
1:53:36
Well, what could I do here? Well, I want to put a house there. Well, let's go ahead and create a variable called house.
1:53:42
And if you think back to our discussion of libraries, in the random module, there is a function called choice that, if you pass in a list of choices,
1:53:51
like self.houses, that will pick a random house out of those four. And then on line 7, I can pass it in.
1:53:58
If I want to tighten this up, let me just go ahead and highlight that code, get rid of the variable. It's technically unnecessary.
1:54:04
And because the line of code is still pretty short, I'm OK with just putting it all in one line. But I could certainly use the variable like I did a moment ago.
1:54:13
So what have I done? In my init function, I have defined a initialization of the object
1:54:20
that stores in self.houses the list of four houses. And then, in sort, I'm accessing that same list,
1:54:26
but I'm randomly choosing the set of houses there. Now, why have I done it in this way?
1:54:31
This, too, is general convention. Any time you have a list of things that-- who knows? Maybe will change over time.
1:54:38
Places like Harvard have constructed new houses over the years, so you might have to change the list of available houses.
1:54:43
It didn't happen in seven books or eight films of Harry Potter. But you could imagine maybe Hogwarts eventually
1:54:49
has a fifth house, so there's generally some value in putting list of constants
1:54:54
toward the top of your file, toward the top of the class so it's just obvious what the list of values is.
1:54:59
You don't want to necessarily tuck it away in some function, like sort, especially if you might want to use that function--
1:55:06
sorry, especially if you want to use that list in multiple functions, not just sort. But if I kept adding to this class, you might
1:55:12
want to use that same list of houses in multiple functions. So let's keep it in the object itself by storing it in self.houses.
1:55:20
All right, well, we're about to change the course of history here perhaps. Let me do Python of hat.py, and I think we're about to assign Harry
1:55:27
to one of those four houses randomly. Huh, NameError.
1:55:33
Name 'random' is not defined. Well, wait a minute, where did I go wrong here?
1:55:38
Thinking back to our class on libraries, why did my code break and not tell me
1:55:43
where Harry is to be? AUDIENCE: You did not import the random library.
1:55:48
DAVID J. MALAN: Exactly. If the random library or module is something I want to use, I need to tell Python that at the top of my file.
1:55:55
So let me go up here and do import random. And then, below that, let me go ahead and clear my terminal window
1:56:01
and try again. Python of hat.py, crossing my fingers, seeing where Harry is going to end up.
1:56:08
And, OK, Harry as of now is officially in Hufflepuff, despite everything you've read or seen.
1:56:14
Well, let's run this again. Let me clear my window and run Python of hat.py, and now he's in Ravenclaw.
1:56:19
That's consistent with using random. Let's clear that and run it again. He's still in Ravenclaw, but that could happen,
1:56:25
even though there's four choices. Let's do it again. Hufflepuff-- back in Hufflepuff. We can't seem to get the right answer.
1:56:31
Now he's in Gryffindor, albeit randomly. So we seem to have a program that, based on these limited tests,
1:56:37
seems to be assigning Harry to a house randomly. Now I'm somewhat lazily just letting sort print out this value.
1:56:45
I could do something else, like return a string, and then let me, on line 13, do the printing for me.
1:56:51
But for now, I think we have an example of a class called hat that,
1:56:57
nonetheless, applies some of our lessons learned thus far today, where I've created a class-- because a sorting hat is, frankly--
1:57:03
well, I was about to say real world entity, but really a fantasy world entity. And indeed, that's a, perhaps, common heuristic or mental model to have.
1:57:11
When should you use a class to represent something in your code? Very often, when you're trying to represent some real world entity
1:57:20
or fantasy world entity, like a student, which is something in the real world,
1:57:25
like a sorting hat, which, OK, doesn't exist, but hat's certainly do, so quite reasonable to have a class for hat.
1:57:32
And that's not always the case that classes represent real world entities. But we've seen thus far that int and stir and list and dict-- these
1:57:42
are all structures that you might have in the real world. We have integers and strings of text and other things.
1:57:47
So it rather makes sense to represent even those things, more technically, using a class as well.
1:57:52
You could use just a dictionary to represent a student or a hat. But again, with classes come all this and even more functionality.
1:58:00
But I honestly am not using classes in, really, the "right way" here.
1:58:06
Why? Well, in the world of Harry Potter there really is only, to my knowledge, one sorting hat.
1:58:12
And yet, here I have gone and implemented a class called hat. And again, a class is like a blueprint, a template,
1:58:20
a mold that allows you to create one or more objects thereof. Now, most of my programs Thus far have been pretty simple,
1:58:27
and I've just created one student. But certainly, if I spent more time and wrote more code, you could imagine writing one program that
1:58:33
has a list of students-- many more students than just the one we keep demonstrating.
1:58:38
Yet it would be a little weird-- it's a little inconsistent with the real or the fantasy world of Harry Potter to instantiate one, two, three or more sorting hats.
1:58:48
There really is just one. Really one singleton, if you will, which is a term of art in a lot of contexts of programming.
1:58:54
So let me propose that we actually improve the design of the sorting hat so that we don't have to instantiate a sorting hat because right now this
1:59:03
is kind of allowing me to do something like hat 1 = hat, hat 2 = hat, hat 3 =,
1:59:08
and so forth. I don't really need that capability. I really just need to represent the sorting hat with a class,
1:59:15
but I don't really need to instantiate it. Why? Because it already exists. I need just one. So it turns out, in Python, that, up until now,
1:59:23
we've been using, as I keep calling them, instance methods-- writing functions inside of classes that are automatically passed a reference
1:59:30
to self, the current object. But sometimes you just don't need that. Sometimes it suffices to just know what the class is
1:59:37
and assume that there might not even be any objects of that class. So in this sense, you can use a class really as a container for data
1:59:45
and/or functionality that is just somehow conceptually related-- things related to a sorting hat.
1:59:52
And there's this other decorator or function called @classmethod that allows us to do just this. So let me go back to my code here.
1:59:59
And let me propose that, if I'm not going to instantiate multiple houses,
2:00:05
I don't really need this init method because that's really meant to initialize specific objects from that blueprint, that template,
2:00:12
that mold. So let me get rid of this. But if I get rid of this, I no longer have access to self.
2:00:17
But that's OK because it turns out, in addition to their existing class methods, there are also what we might call class variables.
2:00:26
And class variables exist within the class itself. And there's just one copy of that variable
2:00:33
for all of the objects thereof. They all share, if you will, the same variable-- be it an int or str
2:00:40
or, in this case, a list. So what I've done here is define, inside of my hat class, in a class variable
2:00:49
called houses-- I don't say self because self is no longer relevant. Self refers to specific objects.
2:00:54
I want a variable inside of this class, a.k.a. A class variable that equals that list.
2:01:00
Because it's inside of this hat, now, class, I can use that list in any of my functions.
2:01:07
I've only got one now, called sort. But if I had more, it would be accessible to all of those methods as well.
2:01:12
And with sort, it also doesn't really make sense to sort within a specific sorting hat because, again, I
2:01:19
only want there to be one. So I can actually specify that this is class method by saying @classmethod.
2:01:25
And I don't pass in self anymore. I actually, by convention, pass in a reference to the class itself.
2:01:33
It's typically written as cls. Why? Well, if you wrote C-L-A-S-S, that would actually conflict with the keyword
2:01:40
"class" that we keep using up here. So the world realized that, oops, we can't reuse that same phrase here.
2:01:47
So let's just call this class. This is useful in some contexts including this one. Why? Well, notice what I can now do.
2:01:54
I can now change self to be just class. Why? Because houses now-- not an instance variable, accessible via self.houses.
2:02:02
It is now a class variable, accessible via class.houses, or technically cls.houses in this case.
2:02:10
But now the final flourish is this. Now, I don't have to instantiate any hat objects as I used to on here, line 13.
2:02:19
I can just use functionality that comes with this class. So I'm going to delete that line altogether.
2:02:24
I'm going to capitalize the hat on this new line 13 and just say hat.sort,
2:02:32
("Harry"). So what have I done? I've not bothered instantiating an object of type, hat.
2:02:38
I am just accessing a class method inside of the hat class that-- you know what?
2:02:43
Is just going to work. This is how class methods work. You use the name of the class, capital letter and all, dot method name,
2:02:51
passing in any arguments you want. Python is going to automatically pass in some variable via which
2:02:57
you can refer to that class in that function that you've implemented inside of that class
2:03:02
so that I can do something like this. It's not that I want a variable called houses locally in this function,
2:03:07
I want the variable called houses that's associated with this current class so I can still access this same list that I defined on line 6.
2:03:17
And now, if I go back down here to my terminal and run Python of hat.py, Enter, Harry is still in Hufflepuff once more.
2:03:24
Harry is still in Hufflepuff once more. Harry is back in Gryffindor, at least randomly.
2:03:31
Questions, now, on these class variables or these class methods,
2:03:36
which are in contrast with instance variables and instance methods.
2:03:41
And the one thing, at least, that's a little strange here is that, even though there's a decorator called @classmethod,
2:03:47
there is not one called @instancemethod. A method is just automatically a so-called "instant method" when
2:03:55
you define it without any decorator. AUDIENCE: Can you have a class inside another class? DAVID J. MALAN: You can.
2:04:01
You can define one class inside of another. Generally speaking, this isn't done, but there are cases where it can be helpful, especially
2:04:08
for larger, more sophisticated programs. So yes, it is possible.
2:04:13
Other questions. AUDIENCE: The question was about the self.houses. When we remove it and we pass data, variable is created itself,
2:04:25
s why we remove the self? DAVID J. MALAN: So in the previous examples-- both of the hat demonstration and also all of the student
2:04:32
demonstrations-- we were creating a student object by calling Student, capital S, open parenthesis, close parenthesis,
2:04:40
with, eventually, name and a house passed in. And then we were using the double underscore init method
2:04:46
to initialize the self.name and the self.house instance variables
2:04:52
therein to those respective values. In this latest version of the sorting hat,
2:04:57
I haven't bothered with self anywhere, only because, conceptually, I don't need or want there to be multiple hats in the world.
2:05:05
I'm just using the class as a container to bundle up this list of houses,
2:05:11
this sorting functionality. Maybe eventually all add more functionality to it. But that's it. And so sometimes you can use object-oriented programming
2:05:18
in this somewhat different way when you want there to be functionality but it's not specific to any one specific hat.
2:05:25
It's specific to the sorting hat itself. How about one other question now, on these class variables or methods-- just
2:05:33
another way of using object-oriented programming but to solve a somewhat different problem? AUDIENCE: Well, what's the difference between the class
2:05:40
hat and a function of hat? DAVID J. MALAN: A good question.
2:05:46
So why are we using a class at all and not just having a file called hat.py with a variable called
2:05:51
houses and a function called sort? Why are we adding this complexity? In this particular case, we don't necessarily need to.
2:05:58
I could absolutely go in here. I could get rid of the class. I could undo this indentation.
2:06:05
I could get rid of this decorator. And I could get rid of hat dot. And I could just do this and additionally
2:06:12
let's say, let's get rid of class here. Let's get rid of class here. And now run Python of hat.py, Enter, and it still works.
2:06:19
Put Harry in the wrong house, but that's what we have-- what happens randomly. That's fine, too. What we're introducing today, by way of object-oriented programming,
2:06:27
is just a different way of modeling the world. It's not really compelling with an example like this,
2:06:32
frankly, that's relatively simple. It's not very complex. There's not much functionality. Honestly, the version that we just typed up-- these 10 lines-- this is fine.
2:06:40
This solves this problem. But as our code gets longer, as we start collaborating with other people, as the problems we're trying to solve with code get more sophisticated,
2:06:48
you're going to find that your code gets messy quickly. And you're going to find that you have a huge number of functions, for instance,
2:06:55
in one file. And some of them are related to each other, but some of them are not. Well, at that point, wouldn't it be nice to just organize them
2:07:02
a little differently? And in the world of Harry Potter, let's have a class for student; let's have a class for Professor; let's have a class for the sorting hat;
2:07:09
let's have a class for something else. And so once your world gets much more complicated than some of the demonstrations we do here in class when we want to focus
2:07:17
on individual ideas, object-oriented programming is just a way of encapsulating related data--
2:07:24
that is, variables-- related functionality-- that is, methods-- inside of things that have names.
2:07:29
These things are called classes. So it's just another way to solve problems. And when we focused on libraries a couple of weeks back,
2:07:36
that, too, was another solution to the same problem. You could define your own modules or packages, put some of your data
2:07:42
and/or functionality in there, and that's fine, too. And sometimes which one you should use overlaps.
2:07:48
If you're familiar with Venn diagrams, the overlapping region might mean that you could use a class; you could use a module or a package;
2:07:54
you could just use a single local file. Over time, you'll develop an instinct and maybe even
2:07:59
a personal preference for which tool to use. All right, let me propose, now, that we apply this same idea of a class method
2:08:08
to clean up one other thing as well. Let me close that hat.py and reopen student.py as we left it earlier,
2:08:16
and let me go ahead and simplify it just a little bit. I'm going to go ahead and get rid of the properties,
2:08:22
not because there's anything, wrong with them, but just because I want us to focus on some of the key ideas when we began with this program.
2:08:29
So I'm going to go ahead and keep main as well. I'm not going to adversarially try to change Henry's address there.
2:08:35
I'm going to instead go ahead, though, and just print the student. But this is the thing I want to focus on here.
2:08:41
This, in our previous student examples, was a missed opportunity to clean up my code.
2:08:48
Well, what do I mean by that? Well, up here at the top of this file-- even though I've simplified it, but getting rid of the properties
2:08:53
and all of that error checking-- because I want to focus on the essence of this class now-- just the student's name and the house and the printing thereof.
2:09:00
This is, by nature of classes in object-oriented programming, theoretically, all of my student-specific functionality.
2:09:09
That is to say, if I have functionality and data related to a student, you, the programmer, my colleague, would assume
2:09:16
that it's all bundled up, encapsulated, so to speak, inside of the student class. And yet, if you scroll down further, what is this?
2:09:24
There's a function called get_student that just exists elsewhere in this file that prompts the user for a name, prompts the user for a house,
2:09:31
creates the student object, and then returns. That's not wrong. It works.
2:09:36
And we saw many, many times it kept working. But this is a little weird because, if this
2:09:42
is a function that helps you get a student, helps you get the name of a student and the house of a student, why isn't
2:09:48
that functionality in the class itself? After all, as my code gets more and more complicated and does more things,
2:09:54
I'm going to be looking at the student class for all student-related functionality. I'm not going to be scrolling down, expecting that, oh, maybe there's
2:10:00
some other student functionality just randomly later in this file. So it's not wrong.
2:10:05
But this is, again, evidence of maybe bad design-- not so much with this small program.
2:10:11
But this is an example, again, of code smell. Something smells a little off here. This is probably going to get us in trouble
2:10:17
by separating related functionality. So again it's a design principle, not a correctness concern.
2:10:24
But class methods allow us to address this, too. Let me go ahead and do this.
2:10:29
I'm going to delete get_student all together, leaving only main as my other function here.
2:10:35
And inside of my student class, I'm going to do this. I'm going to define a function, even more simply called, get.
2:10:42
And by nature of how class methods work, it's going to take in the name of the class itself
2:10:47
or a reference thereto as an argument. And I'm going to move the functionality from get_student into the student
2:10:53
class. And I'm going to do this-- name equals input, quote, unquote, name, house
2:10:58
equals input, quote, unquote, house. And then what this function is going to do
2:11:04
is return a new student object by calling class, which, again, is just
2:11:11
an automatically passed-in reference to the class itself, passing in name and house.
2:11:17
And I will admit this syntax seems a little strange that now I'm calling cls
2:11:22
and I'm passing in these arguments. But let me do one final fix here. Let me go to the top of this function and more
2:11:28
explicitly say this is a class method. This solves a potential chicken and the egg problem, so to speak,
2:11:34
whereby one needs to come before the other, potentially. So what am I doing here? Inside of my student class, I now have a function called get.
2:11:43
It is, I shall claim, a class method what does that mean. It just means I can call this method without instantiating a student
2:11:53
object first. Therein lies the potential chicken and the egg problem. And if unfamiliar, that's an expression, meaning, well, and did the world
2:12:00
have chickens first that laid eggs, or was there an egg that then yielded the chickens, but how did the egg get there?
2:12:06
It's this weird, circular problem. And that's what we're facing here. It would be weird if you had to create a student object in order to call get,
2:12:16
in order to get another student object. That sounds messy. Let's just get a student via a class method
2:12:24
that, by definition, does not require you to create a student object first. Just like the hat, in its final form, we use the hat class
2:12:33
to just say Hat, capital H, dot sort. We didn't need to create a hat first. We just used the class itself.
2:12:39
So what am I going to do here now? Let me go down to main. And instead of saying get_student, notice what I can now do.
2:12:46
Student.get, and everything else can stay the same. All I've done now is I've migrated all of my logic
2:12:55
from get_student, which was this own standalone function, but clearly related to students by name.
2:13:01
I've moved the same code, really, to inside of the student class in a more simply named function called get.
2:13:09
But I could still call it get_student if I want. It just seems a little redundant to call it get_student in a student class,
2:13:14
so I'm simplifying. So I have a method called get, but I'm calling it a class method
2:13:20
to avoid that chicken and the egg problem. I want to be able to call a get without having a student object in my universe
2:13:27
already. And the syntax for that is @classmethod. The convention is to give this method at least one argument,
2:13:35
by convention called cls for class, which is just going to be a reference to the class itself. Lines 11 and 12 are identical to what they've always been.
2:13:43
And get_student-- the only new syntax here is this, but this, again, is one of the features of object-oriented programming.
2:13:50
You can now instantiate a student object by just using cls that's passed in.
2:13:57
I technically could use Student, capital S, but it turns out I'm doing what's more conventional because this
2:14:03
will both solve and avoid problems down the line with more complicated code. This line here, on line 13, just means create an object of the current class.
2:14:11
What class is that? Well, whatever cls is. Well, that, by definition of how it all works, is going to be student.
2:14:17
And I want you to initialize it, as always, with name and house. So now, scrolling down, my code is this.
2:14:25
And this is just nice to read. You perhaps have to acquire a taste for this-- and I sound a little odd saying,
2:14:31
this is nice to read. But indeed, student.get just tells me what's going on. I'm going to get a student.
2:14:37
I don't need a separate function written by me called get_student in the file itself. The get functionality is built into the class.
2:14:44
All my student-related code now is together. So let me go down to my terminal window and run Python of student.py, Enter.
2:14:51
Let's type in Harry. Let's type in Gryffindor. And we're back to where we began. But, but, but everything related to students, now, is in this here class.
2:15:00
The only other thing in the file is main and this conditional that we always use to avoid accidentally executing main when we're making
2:15:08
a module or a package or the like. So again, a solution to a problem--
2:15:13
not a big one in the case of a relatively small program, but one that you will eventually encounter as your programs
2:15:19
get longer and longer, with more and more entities to represent.
2:15:24
Questions now on this use of a class method. MICHAEL: Does the class have to be defined before the main function,
2:15:32
in terms of the order of the program? DAVID J. MALAN: A really good question. So when in doubt, let's try this. So let's try to change the order.
2:15:38
Let's move main to the top, which I've often encouraged. So let's go ahead and, above the class, do this.
2:15:44
And notice now that, technically, line two is mentioning student, which does not exist until line 6 and below.
2:15:51
Let me go ahead and clear my terminal and run Python of student.py. So far, so good. Harry-- Gryffindor, OK.
2:15:58
Indeed, Harry's from Gryffindor. The reason, Michael, it does not matter in this case is because we're not actually calling main until the very end.
2:16:06
And just as in the past, that means that Python has a chance to read everything, top to bottom, left to right. So everything exists.
2:16:13
I would say, generally classes are defined at the top of the file. However, it would be even maybe cleaner to move the Classes definition
2:16:21
to its own file and then import it, so essentially to make reusable code by putting it into your own module or package
2:16:28
so that not just this program but many others can use that definition of student as well. Other questions now on classes, class methods, or the like.
2:16:37
AUDIENCE: I wanted to ask, is there a way to declare all the possible--
2:16:44
all the possible attributes of the class? Because it looks so inconsistent.
2:16:51
DAVID J. MALAN: Well, so my takeaway there is this is Python's approach to these principles. Different languages, like Java, just take a different approach
2:16:57
but have very similar features. The syntax just tends to vary. And this is how the Python community chose to implement this idea.
2:17:05
The right mental model, ultimately, is that these instance variables, instant methods belong to or operate on specific objects--
2:17:14
a specific student, a specific hat. Class variables and class methods operate on the entire class
2:17:22
itself or, in turn, all objects of that class, which we've not seen a demonstration of, but it's a higher level concept.
Inheritance
