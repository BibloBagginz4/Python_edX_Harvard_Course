39:19
there are a number of not just attributes or instance variables that you can put inside, but also methods.
39:27
Classes come with certain methods, or functions inside of them,
39:32
that you can define, and they just behave in a special way, by nature of how Python works.
39:37
These functions allow you to determine behavior in a standard way. They are special methods in that sense.
39:45
Now, what do I mean by this. Well, let me go back to VS Code here. And let me propose that I start to define a standard function
39:53
called underscore underscore, or Dunder, as it's abbreviated, init, underscore underscore,
39:59
and then I'm going to go ahead and do open parentheses, and then I'm going to put in here, literally, the word self.
40:06
More on that in just a moment. But now, inside of this function, I'm going to have an opportunity to customize this class's objects.
40:16
That is to say this underscore, underscore init method, or Dunder init method is specifically known as an instance method,
40:25
and it's called exactly this. This is designed by the authors of Python. And if you want to initialize the contents of an object from a class,
40:34
you define this method, and we'll see what it's about to do here. Let me go back to VS Code, and let me do something like this.
40:41
self.name = name, and self.house = house.
40:47
But I don't want to just init this object very generically. I want this method, called init, to take in not just self but name,
40:56
house as well. Now, what in the world is going on? Because there's a lot of weird syntax here.
41:01
There's this Dunder init method-- double underscore, init, double underscore. There's, all of a sudden, this parameter called self.
41:08
And then there's this new syntax-- self.name and self.house. Now you're seeing really a manifestation of object-oriented programming.
41:16
It's not all that different fundamentally from what we've been doing for weeks with dictionaries, by adding keys to dictionaries.
41:23
But in this case, we're adding variables to objects, a.k.a.
41:28
instance variables to objects. Now, what's going on? Let's do this in reverse. Let's go back to the line of code we wrote earlier.
41:34
On line 15, I am treating the name of this class-- Student with a capital S-- as a function.
41:41
And I am passing in two values-- "Name" and "House." What I've highlighted here on the screen, on line 15,
41:48
is generally known as a constructor call. This is a line of code that is going to construct a student object for me.
41:56
Using synonyms, it is going to instantiate a student object for me.
42:02
And again, how is it going to create that object? It's going to use the student class as a template, as a mold of sorts
42:09
so that every student is structured the same. Every student is going to have a name. Every student's going to have a house.
42:15
But because I can pass in arguments to this Student function, capital S,
42:20
I'm going to be able to customize the contents of that object.
42:26
So if you think about the real world-- if you've ever been on a street or a neighborhood where all of the houses look the same but they might be
42:34
painted differently; they might be decorated a little bit differently on the outside, all of those houses might have been built using the exact
42:40
same blueprint-- a mold, if you will. But then you can specialize exactly the finer points of those houses.
42:48
By painting the outside a different color or planting different trees, you can style them differently. Similar in spirit here, we have a Student blueprint
42:57
that's always going to have now a name and a house, but it's up to you and me to pass in any name and any house that we want.
43:04
Now, where is this function? The fact that I'm calling Student, capital, S and then a parenthesis and a closed parenthesis with arguments inside
43:11
suggest that there's a function somewhere in the world that has been defined, with def, that's going to be called.
43:17
Well, as you might have guessed by now, the function that will always be called, by definition of how Python classes work,
43:25
is a function called double underscore, init, double underscore. Why? It's a crazy name, but it's what the authors of Python
43:33
chose to just implement the initialization of an object in Python.
43:38
Now, the only weird thing-- especially weird thing, I will admit, is this. It would be way clearer, to me, too, if the only two parameters for init we're
43:49
just name, house. That's how we've defined every function thus far in the class. You just specify the parameters that you want the function to accept.
43:57
And that lines up with what I'm doing on line 15. I am only passing in two things to the student function.
44:04
But it turns out that the authors of Python need to give us a little bit of help here because suppose that you pass in "Name" and "House" to this init method.
44:14
And a method is just a function inside of a class. What are you going to do with the name and the house?
44:20
Literally, where are you going to put them? If you want to remember the name and the house for this student,
44:26
you've got to be able to store those values somewhere. And how do you store them in the current object
44:32
that has just been "instantiated?" Well, the authors of Python decided that the convention
44:37
is going to be that this init method also, semi secretly, takes a third argument, that has to come first.
44:44
By convention, it's called self, but you could call it technically anything you want. But the convention is to always call it self.
44:50
And self, as its name implies, gives you access to the current object that was just created.
44:56
What does that mean? Again, now, on line 14, now that it's moved down a little bit,
45:02
this line here is a constructor. It constructs a student object. But there's nothing in that object initially.
45:08
There's no name; there's no house. But the object exists in the computer's memory. It's up to, now, you to store the name and the house inside of that object.
45:16
How do you do that? Well, Python will just automatically call this init method for you, and it's going to automatically pass in a reference to an argument that
45:27
represents the current object that it just constructed in memory for you, and it's up to you to populate it with values.
45:34
And what this means is that, inside of your init method, you can literally do self.name to create a new attribute, a.k.a.
45:42
an instance variable, inside of that otherwise empty object and put this name inside of it.
45:48
It allows you to do self.house and store that value of house. Now, you could call these things anything you want.
45:54
They could be n. They could be h, as before. But that's really not very self-explanatory.
46:00
Much better to do this kind of convention. self.name equals name. self.house equals house.
46:06
And this is like installing into the otherwise empty object the value name
46:11
and house and storing them in, really, identically named instance variables in the object.
46:17
And again, an object is just an instance of a class. Now, I know that was a lot of vocabulary.
46:23
That's a lot of weird syntax. So any questions on this init method, whose purpose in life,
46:28
again, is to initialize an otherwise empty object when you first create it? AUDIENCE: So what is the difference between the init method and default
46:36
constructor? DAVID J. MALAN: A good question. So in other languages-- if you programmed before. For instance, Java-- there are functions that are explicitly called
46:45
constructors that construct an object. They initialize it with values. Python technically calls this init method the initialization method.
46:53
It initializes the value. It's on line 15 now of my code, if I scroll back down, that I'm technically
47:00
constructing the object. It turns out there's another special method in Python, that we won't talk about in detail today,
47:07
called underscore underscore, new, underscore underscore that actually handles the process of creating
47:13
an empty object in memory for us. But, generally speaking, you, the programmer, don't need to manipulate the new function.
47:19
It just works for you. Instead, you define your own init method here and init function inside of your class, and that method
47:27
initializes the contents of the object. So there's technically a distinction between constructing the object
47:32
with new and initializing it with init. But in the world of Python, you pretty much only worry about the init method.
47:39
Python generally does the other part for you. A good question. Others?
47:44
AUDIENCE: What about if you want to store more than one name or more than one house? DAVID J. MALAN: A good question.
47:49
If you want to store more than one name or more than one house, you can do this in different ways. You could create other attributes-- technically called instance variables--
47:57
like self.name1, self.name2. But we've seen, in the past, that that is not
48:03
a very good design, just to have multiple variables to store multiple things. Maybe, instead, you have an instance variable called self.names, plural,
48:12
and you set it equal to a list of names or a list of houses. Now, in this case, I don't think that really solves a problem because I'm
48:19
trying to implement a student, singular, so it doesn't really make sense to have multiple first names.
48:24
Maybe a nickname, maybe a last name, so we could add those, too. But I don't think we need multiple names per se
48:29
and, in this case, multiple houses. But absolutely, you could do that using some of our familiar building blocks
48:34
like lists. Other questions? AUDIENCE: How are classes or objects represented in memory?
48:40
DAVID J. MALAN: How are classes and objects represented in memory? So the class is technically just code. It is the code on the top of my file-- lines 1 through fou4--
48:48
that defines that blueprint, that template, if you will. Objects are stored in the computer's memory
48:54
by taking up some number of bytes. So you're probably familiar with bytes or kilobytes or megabytes. There's some chunk of bytes, probably all
49:01
in the same location in the computer's memory or RAM, where those objects are stored.
49:07
But that's what Python, the program, handles for you. Python the interpreter figures out where in the computer's memory to put it.
49:14
You and I, the programmers, get to think and solve problems at this level. Python, the interpreter, handles those lower level details for you.
49:21
How about one final question on classes and objects? AUDIENCE: So my question is if we can the same do
49:28
the same thing with the dictionaries, so why to use classes? DAVID J. MALAN: Good question. If you can do the same things as you can with dictionaries,
49:34
why should you use classes? Because we are just scratching the surface now of what you can do with classes.
49:39
Allow me to go back, now, to my keyboard and show you more of what you can do with classes. But in short, you can do much more with classes.
49:47
You can ensure the correctness of your data much more with classes. You can error-check things.
49:53
And generally, you can design more complicated software more effectively. And we'll continue to see, today, features
49:59
of Python and object-oriented programming more generally that allows us to do just that.
50:04
So let me propose, in fact, that first, let's just tighten up this current implementation, which again has us with an init method that just declares two
50:13
instance variables-- self.name and self.house, house, which, again, just creates those variables inside of the otherwise empty object and assigns
50:21
them values-- name and house, respectively. Let me go ahead and just do one little thing here. I don't really need this student variable.
50:27
Let me just tighten this up so that each time we improve or change the code, we're focusing, really, on just the minimal changes alone.
50:35
So I've not fundamentally done anything different. I just got rid of the variable name, and I'm just returning the return value of this student function
50:43
that's constructing my new object for me. So I'm just tightening things up as we've done many times in the past.
50:48
Well, what if something goes wrong in creating this student? For instance, what if the user does not give us a name, and they just hit
50:56
Enter when prompted for name. I don't want to put in my computer's memory a bogus student object that has no name.
51:04
I'd ideally like to check for errors before I even create it so I don't create a nameless student.
51:09
It would just be weird and probably a bug to have an object that has no name. Similarly, I don't want the user to be able to type
51:16
in something random as their house. At least in the world of Harry Potter, there's really
51:21
only four houses, at Hogwarts at least. There's, again, Gryffindor and Hufflepuff and Ravenclaw and Slytherin-- a list of four valid houses.
51:29
It would be nice if I somehow validated that the user's input is indeed in that list.
51:35
Now, I could do all of that validation in my get_student function. I could check, is the name empty?
51:41
If so, don't create the student object. Is the house one of those four houses? If not, don't create the student object.
51:49
But that would be rather decoupled from the student itself. get_student currently exists as just my own function in my student.py file.
51:57
But classes-- and really, object-oriented programming-- more generally encourages you to encapsulate, inside
52:05
of a class, all functionality related to that class. So if you want to validate that a name exists--
52:12
if you want to validate that a house is correct, that belongs just fundamentally in the class called student itself,
52:20
not in some random function that you wrote elsewhere. Again, this is just methodology because, again, if we think about writing code that gets longer and longer, more and more
52:28
complicated, it should make just intuitive sense that, if you keep all the house--
52:34
all of the name and all of the house-related code in the student, it's just better organization. Keep all of the related code together, and that's probably
52:41
going to set you up for more success. And indeed, that's part of this methodology of object-oriented programming.
52:47
Let me go ahead now and change my students classes init method to do this.
52:53
If the name is blank-- so if not name-- and we've seen this kind of syntax before.
52:59
If you say in Python, Pythonically, if not name, that's doing something like this.
53:04
If name equals, equals, quote, unquote-- but I can do this a little more elegantly. Just say, if not name, would be the more Pythonic.
53:11
Well, I want to return an error. I might want to do something like this.
53:17
Print missing name. But this is not good enough. It does not suffice to just print out missing name
53:24
and then let the rest of the code go through. All right, well, what could I do instead? In the past, we've seen another technique I could do sys.exit,
53:30
and I could say something like missing name, and I could go up here and I could import sys. But this is a really obnoxious solution to the problem.
53:37
Just because you or maybe a colleague messed up and called a function with an invalid name,
53:43
you're going to quit my whole program? That's really, really extreme of a response,
53:49
and you probably don't want to do that if your program is in the middle of running. You might want to clean some stuff up. You might want to save files you don't want to just exit a program sometimes
53:57
in some arbitrary line, just because input was invalid. So I don't think we want to do that either.
54:03
But we do, now, have a mechanism for signaling errors. Unfortunately, I can't do something like this.
54:09
I could try returning none and say, uh-uh, this student does not exist. I'm going to hand you back none instead.
54:15
But it's too late. If we scroll back down to where I'm creating the student, it's on line 17
54:21
now where I've highlighted this code. The student has already been created. There is an object somewhere in the computer's memory
54:28
that's structured as a student. It just doesn't have any values inside of it. But it's too late, therefore, to return none.
54:35
That ship has sailed. The object exists. You can't just suddenly say, nope, nope, there is no object. There is an object.
54:41
It's up to you to signal an error. And how do you signal an error? Well, we've actually seen this before, but we haven't had occasion
54:48
to create our own errors. It turns out, in Python, there's another keyword related to exceptions
54:54
that Python itself uses to raise all of those exceptions we've talked about in the past. When you've caught things like value errors or other such exceptions that
55:04
come with Python, well, it turns out you, the programmer can raise-- that is create your own exceptions when something just really goes wrong--
55:12
not wrong enough that you want to quit and exit the whole program, but enough that you need to somehow alert the programmer
55:18
that there has been an error. Something exceptional, in a very bad way-- something exceptional has happened, and let them try to catch that exception as needed.
55:29
So let me go back to VS Code here and propose that, if the user passes in an invalid name-- it's just empty,
55:36
so there's not a name. Well, what I really want to do is this. I want to raise a value error.
55:43
And we've seen the value errors before. We've created value errors accidentally before. And generally, you and I have tried to catch them if they happen.
55:51
Well, the flip side of this feature of exceptions in a language like Python is that you, the programmer, can also raise exceptions
55:58
when something exceptional happens. And you can even be more precise. You don't have to raise a generic value error and let the programmer figure out
56:05
what went wrong. You can treat value error and all exceptions in Python like functions
56:10
and actually pass to them an explanatory message like, quote, unquote, "Missing name," so that at least the programmer, when they encounter
56:17
this error, knows, oh, I messed up. I didn't make sure that the user has a name. And now, what do you want to do instead?
56:25
Well, now, if you're the programmer, you could do something like this. You could try to create a student except if there's a value error.
56:34
Then you could handle it in some way. And I'm going to wave my hand with a dot, dot, dot, at how you would handle it.
56:40
But you would handle it using try and accept, just like we have in the past, and that would allow you, the programmer,
56:46
to try to create the student. But if something goes wrong, OK, I'll handle it nonetheless.
56:52
So what's new here, again, is this raise keyword, that just lets you and I actually raise our own exceptions
56:59
to signal these errors. Well, let me go back to my code here, and I'm just going to go ahead and not bother trying or catching this error.
57:06
For now, we'll just focus on raising it and assume that, from our recon exceptions, you could add try and accept
57:12
as needed in places. Let me go back to the code here and propose that something else could go wrong with house.
57:18
If there is a name, we're good. But if we're given a house but it's invalid, we should probably raise an exception for that, too.
57:24
So what if we do this? If house is not in the list containing "Gryffindor," quote, unquote,
57:32
"Hufflepuff," quote, unquote-- let's see, "Ravenclaw," quote, unquote, or "Slytherin,"
57:38
quote, unquote, then, with my colon, let's raise another type of value error. But rather than raise a generic value error,
57:45
let's pass in an argument, quote, unquote, "Invalid house." And so here we now see a capability that we
57:52
can do with classes that we can't with dictionaries. If you add an attribute to a dictionary, a key to a dictionary,
58:00
it's going in no matter what. Even if the name is empty, even if the house is a completely random string
58:06
of text that's not one of these four houses, it's going into that dictionary. But with a class, and by way of this init method,
58:12
you and I can now control exactly what's going to be installed, if you will,
58:17
inside of this object. You have a little more control now over correctness. And so now let me go ahead and scroll back down to my terminal window
58:26
and clear it. Let me run Python of student.py. Let me type in something like Harry. Let me type in Gryffindor, Enter, and we see
58:33
that, indeed, Harry is from Gryffindor. What if I made a mistake, though? What if I ran Python of student.py and typed Harry as the name,
58:40
but this time typed in Number Four, Privet Drive, which is where he grew up, instead of his proper Hogwarts house.
58:47
Let me hit Enter now, and now you see a value error. But this isn't one that Python generated for us, per se.
58:54
I raised this error. And therefore, if I went in and wrote more code in my get_student function,
58:59
I could also catch this error with our usual try except syntax. So all we have now is not just classes in our toolkit, but even more powers
59:09
when it comes to exceptions, and not just catching them ourselves but raising them ourselves, too.
59:15
Any questions now on this use of classes and init and now this ability
59:21
to raise exceptions when something goes wrong inside of the initialization? AUDIENCE: So what if the user has a middle name--
59:29
name, middle name, and last name? How would you fix that? DAVID J. MALAN: Good question.
59:35
If you wanted the student to have a first name, middle name, and last name, we could do this in a bunch of different ways.
59:41
The simplest, though, if-- let me clear my screen here, and let me just temporarily do this. Let me propose that the init method take in a first argument, a middle argument,
Validating Attributes
