1:05
expect in general from an algorithm. But along the way, we've actually dabbled in another paradigm known as functional programming with Python whereby we've
1:14
been able to pass functions around. We even had an anonymous function some weeks ago. And that's evidence of features of a functional programming language,
1:22
even though we've just scratched the surface thereof. Today we focus on another paradigm, and this one in more detail--
1:28
namely object-oriented programming. And now, while some of you might have prior programming experience and have learned languages like Java, which are, by design, fundamentally
1:36
object-oriented, Python indeed allows you a bit of flexibility when it comes to how you solve problems with code.
1:43
But it turns out object-oriented programming is a pretty compelling solution to problems
1:49
that you invariably encounter as your programs get longer, larger, and more complicated.
1:54
So indeed, OOP, for our purposes, is going to be a solution to a problem that builds on so many of the lessons past.
2:00
So let's go ahead and do this. Let's start by writing a program very procedurally
2:05
by opening up VS Code here. I'm going to go ahead and create a program called student.py.
2:10
And in this program, I want to do something relatively simple initially, as we might have done some weeks ago now, where I just
2:18
ask a user for their name and, maybe in the context of the Harry Potter universe, their house, and just print out where that student is from.
2:26
And let's gradually enhance this program by adding more and more features to it and see if we don't stumble upon problems that, up until now,
2:33
we might not have had very elegant, well-designed solutions to. But if we introduce, explicitly, object-oriented programming
2:40
as a programming technique, I bet we can clean up our code and set the stage for writing even more sophisticated programs, longer programs
2:47
down the line. So in student.py, let me go ahead and do a name variable, setting it equal to the return value of input,
2:54
and just prompt the user for their name like this. And then let me go ahead and do the same for a house variable
2:59
and prompt the user for their house, using input like this. And let's do something super simple now.
3:05
Let's just go ahead and print out an f string that says something like name from house,
3:11
just so that I can confirm that the contents of these variables are indeed as I expect. I'm not going to do any error checking or trimming
3:17
or anything like that for now. I'm really just going to spit back out whatever the user just typed in. All right, let me go ahead and run Python of student.py.
3:24
Let's use our go-to, like Harry, as in Harry Potter, from Gryffindor. And when I hit Enter, now let's see if I see that Harry from Gryffindor
3:32
is indeed the case. All right, so I think we have a working program at this point, but let's now introduce some of those lessons learned way back from week zero
3:40
where we started writing our own functions, not necessarily because it solves the problem more correctly--
3:46
I daresay this is correct as is. But it begins to give us building blocks that we can extend so
3:52
as to solve more complicated programs. So let me go back up to student.py, and let's go ahead now and do this.
3:58
Let's put the entire logic I just wrote inside of our typical method called main, and let me indent those three lines so that at least they're
4:05
now combined into one main method. But instead of using input on line 2 an input on line 3,
4:12
don't we go ahead and assume, for the moment, that we've got some function called get_name in the world, and let's go ahead and assume we've got another function like get_house
4:19
in the world that don't take parameters. But their purpose in life is, by their name, going to be to get the user's name and to get their users house, respectively.
4:28
And then I'm going to print out the exact same f string as before. I, of course, need to implement these functions now.
4:34
So let me go lower in my file and define a function called get_name. Nothing in these parentheses because it's not going to take a parameter.
4:41
And I'm going to go ahead and do something like name equals input ("Name"), just like before, and then I'm going to go ahead and return name.
4:48
So it's a super simple function, but it's an abstraction. I now have a function called get_name whose implementation details
4:55
I don't have to care about anymore. I just know that the function exists. And I can tighten this up, in fact, . Don't really need a name variable on line 8
5:02
if I'm immediately going to return that same name variable on line 9. So let me just tighten this up a little bit even though it doesn't change the functionality
5:09
and just immediately return the return value of the inputs function call here.
5:15
Let's do something very similar now for get_house, which will similarly take no arguments. I'm going to go ahead and return the return
5:22
value of input, this time prompting the user for their house. And I need one final detail. At the very bottom, let's continue our habit of doing if the name of this file
5:32
equals, equals, quote, unquote, main, then let's go ahead and actually call main and recall that we have that in place
5:38
so that, if this eventually becomes part of a module, a library of sorts, I don't accidentally call main blindly.
5:44
I only do it if I mean to run main from the command line on this file.
5:50
All right, so if I didn't make any mistakes here, let me go ahead and, in my terminal window, again, run Python of student.py, Enter.
5:57
Let's type in Harry, Enter. Let's type in Gryffindor, Enter. And we're set.
6:02
Harry from Gryffindor seems to still be working. So we haven't really solved the problem any more correctly,
6:09
but I've laid the foundation to maybe now do some more interesting things because I've had these building blocks in place.
6:16
But let me propose that we could be doing this a little bit differently. get_name, get_house is fine.
6:23
But at the end of the day, I'm really trying to get a student from the user. I want their name and their house, not just one or the other.
6:30
So maybe it would be a little cleaner still to define a function called get_student and let
6:36
get_student do all of this work for us. Now, theoretically, get_student could call get_name and could call get_house.
6:43
But because these functions are so short, I think I'm OK with just defining one function, called get_student,
6:48
that similarly won't take any arguments. But it's going to do two things. It's going to get the students name, by prompting them with input as before.
6:55
And it's going to get the student's house, by also prompting them as before.
7:01
Now, hmm. I want to return the student, but I think I might have painted myself into a corner
7:06
here because I now have two variables-- name and house. And yet, up until now, we've pretty much returned one or the other.
7:13
We've returned one value. So any suggestions for how we can perhaps solve this problem that I just created for myself, whereby I want to return,
7:22
really, a student, but I currently have a name variable and a house variable.
7:28
I'd minimally like to return both of those. AUDIENCE: I believe that, we can return a dictionary,
7:33
includes the name and the house. DAVID J. MALAN: Yeah, so we absolutely could return a dictionary-- a dict object in Python, whereby maybe one key is name;
7:41
one key is house; and the values thereof are exactly the values of these variables. So we could totally do that.
7:46
I worry that that might be getting a little complicated. I wonder if there's a simpler way instead.
7:51
Any other instincts-- even if you're not sure it would work? AUDIENCE: Return both name and house? DAVID J. MALAN: Return both name and house.
7:58
I like the sound of that. It sounds simple. I don't have to figure out what a dictionary is going to look like. And in fact, this, too, would be a valid approach,
8:05
even if you've not seen this before. It turns out, in Python, that you can return multiple values,
8:11
but that's a bit of a white lie. Or we could take Muhammad's approach of actually returning a dictionary and putting multiple keys therein.
8:17
So here, again, we have yet another example of how you can solve the same problem in at least two ways, and I daresay we're about to see even more.
8:24
So one way you could solve this problem, whereby you want to return multiple values, would be to do something like this.
8:32
I could go ahead and literally return not just name, but I could put a comma and also return house.
8:39
This is not necessarily something you can do in other languages if you have programmed in other languages before. It depends on the language.
8:45
But it looks like, thanks to this comma, maybe I can, in fact, return two values as [INAUDIBLE] proposed.
8:51
Well, if I'm returning to values in this way on line 10, how do I get both values at the same time?
8:57
Well, there's a couple of ways. Let me go up to my main function. I know, minimally, I'm going to have to change the get_name
9:04
and get_house to get_student. But what am I going to store the return value in? I think I could actually do this.
9:11
And we have seen this technique before, where you can unpack, so to speak, sequences of values that are coming back.
9:17
And indeed, consider this to be exactly that. name, house is some kind of sequence that I'm returning of values-- name, house.
9:25
So if I want to unpack those and store the return values in two separate variables, I can, in fact, use the commas on the left-hand side of my assignment operator, the equal sign,
9:34
to do just that. Now, to be clear, I don't need to call these variables name and house here.
9:40
I could simplify this and use just n here and h here, and then I could return just n and h.
9:46
But I would argue that's not very clear to the reader as to what's going on. So I think, in this case, even though it's
9:52
a coincidence that I've used the same variable names in get_student and get_name, and in main, it's a little more readable to someone like me.
9:59
So I'm going to leave it as is. Well, let's go ahead and see, now, if this works. Let me clear my screen down here and run Python of student.py, Enter.
10:07
Let's again type in Harry. Let's again type in Gryffindor, Enter. And voila, we still see that Harry is from Gryffindor.
10:14
But what are we actually doing here? What are we actually doing by returning this value? Well, it turns out that what we've just done is use a tuple.
10:24
A tuple is another type of data in Python that's a collection of values--
10:29
x, y or x, y, z. It's similar in spirit to a list, in that sense, but it's immutable.
10:36
It's not mutable. Now, what does that mean? A list, as we've seen it before, is a data structure in Python that you can change the values of.
10:43
You can go into bracket 0 for the first location and change the value there. You can go to bracket 1, bracket 2, bracket 3 and actually change
10:50
the values in lists. But if you have no intention of changing the values of variables and you want to return, effectively, multiple values,
10:57
you don't have to even return it as a list. You can return it as a tuple instead, just by using a comma.
11:03
And it turns out we can make explicit that-- here's the white lie. I'm not actually returning to values per se.
11:10
Whenever you use a comma in this way on line 9, you're actually returning one value, which is a tuple.
11:17
Inside of that tuple now are two values. So it's similar in spirit to returning one list with two thing Here
11:23
I'm returning one tuple with two things. And the mere fact that I've used a comma and nothing else
11:28
tells Python that I indeed want to return a tuple. But there's more explicit syntax that we can use instead.
11:34
I can actually-- more verbosely-- put explicit parentheses around the values
11:39
of this tuple just to make more clear to me, to the reader that this isn't two values per se. This is one value with two things inside of it.
11:46
And what I can actually do then, too, is-- I don't have to unpack this up here, so to speak. I can actually go up here and maybe give a more apt name, like student,
11:54
and I can name the value, or rather name the variable in which I'm storing the return value of get_student as,
12:01
quote, unquote, "student." So maybe this is a little better design now because I'm sort of abstracting away what a student is.
12:08
It's implemented at the moment as a tuple with two values. But at least, now I have a variable called what I mean, a student.
12:15
But there's going to be a catch. On line 3, I still want to print out that student's name and their house.
12:21
But I don't have a name variable anymore, and I don't have a house. And I also don't have a dictionary, as was proposed earlier, so I can't even
12:28
go at those keys by name. But what a tuple is-- it's very similar in spirit to a list,
12:35
but it is indeed just immutable. And what I mean by that is I can still index into it numerically by saying student [0] for the item
12:45
in the first location in that tuple. And then over here, instead of house, I can say student [1].
12:50
student [1] is going to give me the second location in that tuple. Let me go ahead and clear my terminal window.
12:56
Again, run Python of student.py. Let's type in Harry. Let's type in Gryffindor, Enter, and we still have some working code.
13:04
Let me pause here now and see if there are any questions on this technique of returning a tuple
13:11
and indexing into it in this way. AUDIENCE: I guess, what's an actual use case where
13:17
you would use a tuple versus a list or something else that's similar? DAVID J. MALAN: It's a really good question.
13:23
When would you use a tuple versus a list? When you want to program defensively, or, in general,
13:28
when you know that the values in this variable shouldn't change, so why would you use a data type that allows them to be changed?
13:34
It just invites mistakes, bugs down the line, either by you or colleagues who are interacting with your code.
13:40
So tuple is just another way where you can increase the probability of correctness by just not letting anyone, yourself included,
13:47
change the contents therein. So it's just another tool in your toolkit. But let's make clear, then, what I mean by "immutable."
13:55
Again, I claim that "immutable" means that you cannot change the value. Well, let's go ahead and try to do this.
14:01
Let me go ahead and run this program once more as is-- Python of student.py. Let me go ahead and type in, for instance--
14:09
how about Padma's name? And I'm going to go ahead and say that Padma is in Gryffindor as in the movies.
14:14
And we see-- Padma from Gryffindor. But technically, I went down this rabbit hole in looking at Harry Potter
14:20
more closely. Technically, in the books, Padma, I believe, was from Ravenclaw. So this is actually a mistake or an inconsistency
14:27
between the movies and the books. Let's see if we can't fix this inconsistency in our code. So how about we do this?
14:33
If the student's name that's inputted equals Padma, why don't we override whatever the house is
14:40
and change it to be properly Gryffindor. Let me go ahead and do if student--
14:46
now, if I want to get at Padma's name, I'm going to have to do student [0]. I have to know what location the name is in in this tuple.
14:52
But if that value equals equals Padma, let's go ahead with this if statement
14:57
and make a change. Let's change the student's [1] value. So the second value, if we're zero indexing--
15:04
let's change it to be another house in the world of Harry Potter called Ravenclaw. So I'm just fixing maybe the user's input.
15:11
They watched the movie so they type in Padma Gryffindor, but, mm-mm, in the books, it was Padma from Ravenclaw.
15:17
All right, let me go ahead and go down to my terminal window, clear my terminal, and do Python of student.py, Enter.
15:24
I'm going to do Harry as well as Gryffindor, just to demonstrate that that is still working as intended.
15:29
Let me clear my screen again, though, and run Python of student.py on Padma, and I'll put her, too, in Gryffindor, as in the movies, and hit Enter.
15:37
And now I just see a big mess of errors on the screen. Some kind of exception has been thrown.
15:42
And indeed, a type error has happened. I'm using a data type wherein there's an error, and what is that error?
15:48
Well, 'tuple' object does not support item assignment. It's a little arcanely expressed-- that is, it's not really very user friendly.
15:57
But if you think about what those words mean, 'tuple" object does not support item assignment. So assignment is copying from right to left.
16:03
So somehow, that's invalid. And here is a manifestation of the immutability of tuples.
16:10
You cannot change location 0 or 1 or anything inside. That is a feature. That is the design of a tuple.
16:17
So if I want to override that, I think I'm going to have to use a different type of data that we've used before--
16:23
namely a list, and that's fine. If you want to enable yourself and colleagues using your code
16:28
to change the contents of that container, well, we can go ahead and return not a tuple using
16:34
explicit parentheses or no parentheses, just the comma, but I can use square brackets. And if I'm using square brackets on the left and the right,
16:41
this is indeed explicitly a list. Same idea, but it's mutable.
16:47
That is to say you can change the contents of a list. So making no other changes, just returning a list
16:53
with square brackets instead of a tuple with parentheses or just the comma. Let me go ahead now and run Python of student.py, Enter.
17:01
Let me type in Harry and Gryffindor again. That's still working. Good to see.
17:06
Let me run this once more and type in Padma and Gryffindor, as in the movies, but no, now we've corrected it to be Padma from Ravenclaw,
17:15
as in the books instead. Any questions now on tuples versus lists or this idea
17:22
of immutability versus mutability. AUDIENCE: Can we use a nested tuple in Python, like a nest list?
17:31
DAVID J. MALAN: Absolutely. You can have not only nested lists in Python, where one of the elements in a list could be another list-- so you
17:38
have some square brackets out here; you might have some other square brackets inside. You can absolutely do the same with a tuple as well.
17:44
There is no constraint on the types of values you can put in there. We've not had occasion to do that in this case.
17:50
I'm just returning a simple tuple with two elements. But yes, you could absolutely do that, too.
17:56
Other questions on tuples versus lists? AUDIENCE: OK, for example, when I see the square brackets,
18:03
is it mainly used for the list? DAVID J. MALAN: Oh, a really good question. Sort of. So when you create a value like a list, you use square brackets,
18:12
and that would indeed be a visual indicator that this is definitely a list. If you instead see parentheses, that's a visual indicator,
18:19
when creating a value, that it's definitely a tuple. However, somewhat confusingly, both lists and tuples
18:26
use square brackets when you access the contents of them. When you index into them at location 0 or location 1
18:34
you always use square brackets. So that's the distinction there. Good question. Allow me to propose now, if I may, that we solve this problem yet another way,
Dictionaries
