26:47
another way of solving this problem. And I would argue that there's now an opportunity at hand.
26:53
Even though this program isn't particularly complicated-- all I'm doing is collecting a name from the user and a house
27:01
from the user-- you could imagine wanting, longer term, to collect even more information, like the student's patronus or magical spell
27:07
or a whole bunch of other information that might belong in a student. And right now, we're just using these very general purpose data
27:15
types in Python-- a tuple to combine some values together; a list to do the same, but let us change it later; a dictionary, which is more powerful
27:23
because it's a little more structured. It does have keys, and it has values, not just values.
27:28
But you know what? We wouldn't have to be having this conversation if the authors of Python had just given us a data type called student.
27:37
Wouldn't it have been nice if there were just a type of variable I could create in my code called student?
27:42
Then we wouldn't have to figure out, well, do we use a tuple or a list or a dictionary? But that's pretty reasonable.
27:48
You can imagine just how slippery of a slope that is, so to speak, if the creators of a language had to anticipate
27:55
all the possible types of data that programmers like you and me want to store in your programs.
28:00
So they just gave us these general purpose tools. But they gave us another general purpose tool
28:05
that's going to allow us to create our own data types as well and actually give them names, and that terminology is a class.
28:14
A class is like a blueprint for pieces of data objects.
28:20
A class is a mold that you can define and give a name. And when you use that mold or you use that blueprint,
28:26
you get types of data that are designed exactly as you want. So in short, classes allow you to invent your own data types in Python
28:36
and give them a name. And this is a primary feature of object oriented programming,
28:41
to be able to create your own objects in this way and, in the case of Python in classes, even give them some custom names.
28:48
So what does this mean in real terms? Well, let me go ahead and come back to VS Code here, and let me propose that we introduce a little bit of new syntax.
28:56
I'm going to go ahead and clear my terminal window first. I'm going to go to the top of my file, and I'm just going to start a thought
29:02
but not finish it yet. I'm going to use this new keyword for classes, called, literally, class,
29:09
so the new keyword we're going to have here. And if I go back to our slides here, this would be the official URL where you can read up more
29:16
on this particular feature of Python. In the official tutorial, class is a new keyword we can use.
29:22
Now, this is coincidentally related to students because students take classes, but it has nothing to do with the fact that we're dealing with students.
29:28
Class is a general purpose term in a lot of languages-- Python among them-- that allow you to define these custom containers
29:35
with custom names for pieces of data. So let's go back to VS Code. Let's use this new keyword.
29:41
And let me propose that we create a class called Student. And by convention, I'm going to use a capital S here,
29:47
and I'm going to go ahead, and with a colon, get to, later, the implementation of this class.
29:52
So I'm just going to use dot dot dot, which is a valid placeholder for now, that just indicates to me that I'm going to come back
29:57
to implementing this later. But as of now, it does, in fact, exist. I now have a student class defined for me that I can now use in my code here.
30:08
How am I going to use it? Well, first of all, let me go down to get_student, and let me change this code to no longer use a dictionary but to use this class.
30:18
I'm going to do this. I'm going to give myself a variable called student, as I've done before, but I'm going to set it equal to capital Student ().
30:28
So I'm going to do what appears to be calling a function and that function, Student with a capital S, notice,
30:35
matches the name that I gave this class at the top of my file. All right, what do I next want to do?
30:41
I'm going to go ahead and give this student a name. Now, if I were still using a dictionary, I would say student, quote, unquote, "name," using square brackets.
30:50
But this is not a dictionary. It turns out classes have what, for now, we'll call attributes, properties of sorts that allow you to specify values inside
30:58
of them. And the syntax for that happens to be a dot. We've seen dots before. We've used it in the context of modules and libraries, more generally.
31:06
This is another similar in spirit use of a dot that allows you to get at something inside of something else.
31:12
So student.name is going to be the syntax I use for giving this student a name.
31:18
And that name is going to be whatever the return value of "Name" is. And then I'm going to go ahead and say student.house to give
31:24
another attribute called "House" and give that the return value of input here, prompting the user for house.
31:30
And then, as before, I'm just going to return student. But now what's really powerful about class,
31:37
and object-oriented programming more generally, is that I've created this custom data type called, literally,
31:43
Student, capital S. I've stored one such student in a variable like I can always do in a variable called student, lowercase s.
31:50
But I could call it anything I want. It just makes sense to call it student as well, but lowercase for clarity.
31:56
And then I'm returning that variable. And because of my syntax in lines 14 and 15,
32:01
that has the result of putting inside of that class a name attribute and a house attribute.
32:09
I just need to make one more change up here. I'm going to go ahead and remove our Padma code, just so we can focus only on what's new,
32:15
rather than fixing her house. And I'm going to go in here and change the syntax that previously was for dictionaries.
32:21
Again, dictionaries use square brackets and then strings in quotes--
32:26
either single quotes or double quotes, depending on the context. Here, though, I'm going to change this to be student.name,
32:33
and over here, I'm going to change it to be student.house. And that's just going to be my new syntax for getting the contents of what
32:40
appears to be a class called student. Let me go ahead and rerun Python of student.py, Enter.
32:47
Let's type in Harry's name as before. Let's put him in Gryffindor, crossing our fingers as we often do,
32:52
and Harry is indeed from Gryffindor. What, though, have I done?
32:58
Let's introduce one other bit of terminology here it turns out that I can create a class, using that class keyword.
33:05
But any time you use a class, you're creating what are called objects. And here is the word objects, as an object-oriented programming, or OOP.
33:14
Let me go back to my code here. And even though I haven't really implemented much of it at all-- I literally just left it with a dot, dot, dot--
33:20
that's enough code, lines 1 and 2, to just invent a new data type called Student, capital S, that may or may not have some future functionality as well.
33:29
That's enough to create a class. What, though, am I doing on line 11? On line 11, what I'm technically doing is creating an object of that class.
33:40
So this, too, is another term of art. You create objects from classes. So if we go back to that metaphor, that a class is
33:47
like a blueprint for a house or a class is like a mold, an object is when you use that blueprint to build a specific house
33:54
or something that comes out of-- in plaster, the mold, when you actually use that mold to create such an object.
34:01
So a class is, again, the definition of a new data type. The object is the incarnation of, or technically instantiation of.
34:10
And another term for objects would actually be an instance. You have instances of classes as well.
34:16
So that's a lot of vocabulary. But at the end of the day, it just boils down to this. You can define your own class, which is really your own data type.
34:22
You can then store attributes inside of it, using this dot notation here. And then you can access those same attributes using code like this here.
34:31
And now, I have a proper "student" data type, and I don't have to hack something together
34:36
using a tuple or a list or even a dictionary. I now have a proper data type called "student" that the authors of Python
34:43
didn't give me; I gave myself. Any questions now on classes, this new keyword, class, or this idea
34:50
of these objects or instances thereof? AUDIENCE: Is the class object mutable or immutable?
34:58
DAVID J. MALAN: A good question. And we've clearly laid the stage for having that conversation about every data type now.
35:03
We will see that they are mutable, but you can make them immutable. So you can get the best of both worlds.
35:10
Now, by writing some actual code-- and we'll write more code than the dot, dot, dot in just a bit, other questions on classes or these objects thereof?
35:18
AUDIENCE: Then what would be the properties of those classes? DAVID J. MALAN: So at the moment, the properties of-- or the attributes of,
35:24
as I've been calling them thus far-- would just be "Name" and "House." It turns out that there may very well be other attributes built into classes
35:32
that we may see before long. But for now, the only two attributes that I care about are the ones that I myself created--
35:38
namely "Name" and "House" or, again, what I would call attributes. And in a little bit, we're going to start
35:43
calling those same attributes, more technically, instance variables. "Name" and "House," as I presented them here in VS Code
35:50
are really just variables called "name" and called "house" inside
35:55
of an object whose type is student. All right, so what more can we do with these classes?
36:02
Well, again, on line 11 is where we're instantiating an object of the student class and assigning it to a student variable.
36:11
We're then adding attributes-- "Name" and "House," respectively-- on lines 12 and 13 currently. Both of those have values that are technically
36:17
strings or strs, because that's what the return value of the input is. But those attributes values could actually be any data type.
36:24
We're just keeping things simple and focusing on defining students in terms of two strings-- "Name" and "House."
36:29
And then, on line 14, we're returning that variable. We're returning that object to main so that we can actually
36:35
print out who is from what house. Well, let's go ahead and add a bit more functionality here because, right now,
36:40
on lines 12 and 13, this is a little manual. And it's a little reckless of me to just be putting anything
36:47
I want inside of this student object. It turns out with classes, unlike with dictionaries,
36:53
we can actually standardize, all the more, what those attributes can be and what kinds of values you can set them to.
37:00
So let me go ahead and do this. Let me propose that it would actually be really nice if, instead of doing this here, let me go ahead
37:08
and simplify my code as follows. Let me go ahead and give myself a local variable called name and set it equal to the return value of input, like we've done many times now
37:17
already. Let me give myself one other variable for now, called house, and set it equal to the return value of input
37:23
as well, prompting the user for their house. And now, instead of creating a student object from my student class
37:30
and then manually putting the name attribute inside of it and the house attribute inside of it, let
37:37
me actually do something more powerful. Let me do this. Let me call that Student function, which is identical to the class name--
37:45
just by defining a class, you get a function whose name is identical to the class name, with the capital letter included.
37:52
But instead of just doing open parenthesis, closed parenthesis, let me pass in the name that I
37:58
want to fill this object with and the house that I want to put in that object as well.
38:03
And now let me set the return value as before to be student equals like this.
38:09
So what have I done that's different? Fundamentally, I'm still getting user input in the same way. I'm using input on line 11 and input on line 12.
38:16
And I just so happen to be storing those return values in local variables. And now we're setting the stage for the more powerful features of classes
38:24
and object-oriented programming more generally. Notice that I'm deliberately passing to this capital S Student
38:31
function, name, house-- I'm passing in arguments to the function. Now, the student class is not going to know what to do with those yet,
38:39
but now I'm standardizing how I'm passing data into this student class.
38:44
And ultimately, it's going to give me an opportunity to error check those inputs, to make sure that the name is valid, that it has a value
38:51
and it's not just the user hitting Enter. It's going to allow me to ensure that it's a valid house, that it's Gryffindor or Hufflepuff or Ravenclaw or Slytherin
38:59
or not just hitting Enter or some random value that the user types in. Because I'm passing "Name" and "House" to the student
39:05
class, this particular function, I'm going to have more control over the correctness of my data.
39:11
So let's now go up to the student class, which, up until now, I left as just dot, dot, dot. It turns out that, in the context of classes,
Instance Methods
